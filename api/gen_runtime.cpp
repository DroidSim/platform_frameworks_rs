/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This program processes the core math function definitions found in runtime.spec.
 * It generates the Renderscript header file "rs_core_math.rsh" which is meant for
 * inclusion in client scripts.
 *
 * This program also generates Junit test files to automatically test each of the
 * functions using randomly generated data.  We create two files for each function:
 * - a Renderscript file named Test{Function}.rs,
 * - a Junit file named Test{function}.java, which calls the above RS file.
 *
 * This program takes one optional parameter, the RS version to target the
 * test files.  The header file will always contain all the functions.
 *
 * This program contains four main classes:
 * - Function: Each instance represents a function, like clamp.  Even though the
 *      spec file contains many entries for clamp, we'll only have one clamp instance.
 * - Specification: Defines one of the many variations of the function.  There's
 *      a one to one correspondance between Specification objects and entries in the
 *      spec file.  Strings that are parts of a Specification can include placeholders,
 *      which are "#1", "#2", "#3", and "#4".  We'll replace these by values before
 *      generating the files.
 * - Permutation: A concrete version of a specification, where all placeholders have
 *      been replaced by actual values.
 * - ParameterDefinition: A definition of a parameter of a concrete function.
 */

#include <cctype>
#include <cstdlib>
#include <stdio.h>
#include <list>
#include <map>
#include <set>
#include <fstream>
#include <string>
#include <vector>

using namespace std;

namespace {

/* TODO rename runtime.spec to rs_core_math.spec.  We could make that an argument, so that we could
 * generate other files too.
 */
const char* SPEC_FILE_NAME = "runtime.spec";
const char* HEADER_FILE_NAME = "rs_core_math.rsh";
const char* AUTO_GENERATED_WARNING =
            "// Don't edit this file!  It is auto-generated by "
            "frameworks/rs/api/gen_runtime.\n\n";
const char* LEGAL_NOTICE =
            "/*\n"
            " * Copyright (C) 2014 The Android Open Source Project\n"
            " *\n"
            " * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
            " * you may not use this file except in compliance with the License.\n"
            " * You may obtain a copy of the License at\n"
            " *\n"
            " *      http://www.apache.org/licenses/LICENSE-2.0\n"
            " *\n"
            " * Unless required by applicable law or agreed to in writing, software\n"
            " * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
            " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
            " * See the License for the specific language governing permissions and\n"
            " * limitations under the License.\n"
            " */\n\n";

class Function;
class Specification;
class Permutation;

/* Information about a parameter to a function.  The values of all the fields should only be set by
 * the parsing function.
 */
struct ParameterDefinition {
    string raw;           // The raw entry in the spec file, e.g. "uint3 v"
    string rsType;        // The Renderscript type, e.g. "uint3"
    string rsBaseType;    // As above but without the number, e.g. "uint"
    string javaBaseType;  // The type we need to declare in Java, e.g. "unsigned int"

    // The number of entries in the vector.  It should be either "1", "2", "3", or "4".
    string mVectorSize;
    // The space the vector takes in an array.  It's the same as the vector size, except for size
    // "3", where the width is "4".
    string vectorWidth;

    string variableName;    // e.g. inX, used both in .rs and .java
    string rsAllocName;     // e.g. gAllocInX
    string javaAllocName;   // e.g. inX
    string javaArrayName;   // e.g. arrayInX
    string javaActualName;  // e.g. actualInX

    bool mIsOutParameter;  // True if this parameter returns data from the script.

    /* Parse the definition from the string. The number is used if the definition has not name.  The
     * number will then be used to generate names like "in2", "in3", etc.
     */
    void parseParameterDefinition(string s, int index);
};

/* Represents a function, like "clamp".  Even though the spec file contains many entries for clamp,
 * we'll only have one clamp instance.
 */
class Function {
private:
    string mName;             // The lower case name, e.g. native_log
    string mCapitalizedName;  // The capitalized name, e.g. NativeLog
    string mTestName;         // e.g. TestNativeLog
    string mRelaxedTestName;  // e.g. TestNativeLogRelaxed

    vector<Specification*> mSpecifications;
    typedef vector<Specification*>::iterator SpecificationIterator;

    /* We kee track of the allocations generated in the .rs file and the argument classes defined in
     * the Java file, as we share these between specifications.
    */
    set<string> mRsAllocationsGenerated;
    set<string> mJavaGeneratedArgumentClasses;

    string mJavaCallAllCheckMethods;  // Lines of Java code to invoke the check methods.

    ofstream mRsFile;    // The renderscript test file we're generating.
    ofstream mJavaFile;  // The Jave test file we're generating.

    static map<string, Function*> sFunctionsMap;  // All the known functions.
    typedef map<string, Function*>::iterator FunctionsIterator;

    explicit Function(const string& name);
    bool writeFiles(ofstream& headerFile, int versionOfTestFiles);
    bool startRsFile();
    bool writeRelaxedRsFile();
    bool startJavaFile();
    void finishJavaFile();

public:
    void addSpecification(Specification* spec) { mSpecifications.push_back(spec); }
    void writeRsAllocationDefinition(const ParameterDefinition& param);
    void writeJavaArgumentClassDefinition(const string& className, const string& definition);
    // Add a call to mJavaCallAllCheckMethods to be used at the end of the file generation.
    void addJavaCheckCall(const string& call);

    static Function* getFunction(const string& name);
    static bool writeAllFunctions(ofstream& headerFile, int versionOfTestFiles);
    // Return the number of functions we've parsed.
    static int numberOfFunctions() { return sFunctionsMap.size(); }
    // Return the largest version number that we have found in all the specifications.
    static int largestVersionNumber();
};

/* Defines one of the many variations of the function.  There's a one to one correspondance between
 * Specification objects and entries in the spec file.  Some of the strings that are parts of a
 * Specification can include placeholders, which are "#1", "#2", "#3", and "#4".  We'll replace
 * these by values before generating the files.
 */
class Specification {
private:
    /* The range of versions this specification applies to. 0 if there's no restriction, so an API
     * that became available at 9 and is still valid would have min:9 max:0.
     */
    int mMinVersion;
    int mMaxVersion;

    /* The cleaned up name of the function, e.g. convert.  As of this writing, it only differs for
     * convert.
     */
    string mCleanName;
    string mTest;

    vector<vector<string> > mReplaceables;

    /* The following fields may contain placeholders that will be replaced using the mReplaceables
     * before generating the code.
     */

    // The name of this function, can include #, e.g. convert_#1_#2
    string mName;
    // TODO we could unify mReturn into the other params
    string mReturn;
    vector<string> mComment;
    vector<string> mInline;
    vector<string> mParam;

    // Substitue the placeholders in the strings by the corresponding entries in mReplaceables.
    string expandString(string s, int i1, int i2, int i3, int i4) const;
    void expandStringVector(const vector<string>& in, int i1, int i2, int i3, int i4,
                            vector<string>* out) const;

public:
    Specification() {
        mMinVersion = 0;
        mMaxVersion = 0;
    }
    int getMinVersion() const { return mMinVersion; }
    int getMaxVersion() const { return mMaxVersion; }

    string getName(int i1, int i2, int i3, int i4) const {
        return expandString(mName, i1, i2, i3, i4);
    }
    string getReturn(int i1, int i2, int i3, int i4) const {
        return expandString(mReturn, i1, i2, i3, i4);
    }
    void getComments(int i1, int i2, int i3, int i4, vector<string>* comments) const {
        return expandStringVector(mComment, i1, i2, i3, i4, comments);
    }
    void getInlines(int i1, int i2, int i3, int i4, vector<string>* inlines) const {
        return expandStringVector(mInline, i1, i2, i3, i4, inlines);
    }
    void getParams(int i1, int i2, int i3, int i4, vector<string>* params) const {
        return expandStringVector(mParam, i1, i2, i3, i4, params);
    }
    string getTest() const { return mTest; }
    string getCleanName() const { return mCleanName; }

    void writeFiles(ofstream& headerFile, ofstream& rsFile, ofstream& javaFile, Function* function,
                    int versionOfTestFiles);
    bool writeRelaxedRsFile() const;
    // Return true if this specification should be generated for this version.
    bool relevantForVersion(int versionOfTestFiles) const;

    static Specification* scanSpecification(FILE* in);
};

// A concrete version of a specification, where all placeholders have been replaced by actual
// values.
class Permutation {
private:
    Function* function;
    Specification* specification;

    // These are the expanded version of those found on Specification
    string mName;
    string mCapitalizedName;
    string mCleanName;
    ParameterDefinition mReturn;
    string mTest;  // one of "scalar", "vector", "noverify", and "none"
    vector<ParameterDefinition*> mParams;
    vector<string> mInline;
    vector<string> mComment;

    string mRsKernelName;
    string mJavaArgumentsClassName;
    string mJavaArgumentsNClassName;
    string mJavaVerifierComputeMethodName;
    string mJavaCheckMethodName;
    string mJavaVerifyMethodName;

    void writeHeaderSection(ofstream& file) const;

    void writeRsSection(ofstream& rs) const;

    void writeJavaSection(ofstream& file) const;
    void writeJavaArgumentClass(ofstream& file, bool scalar) const;
    void writeJavaCheckMethod(ofstream& file, bool generateCallToVerify) const;
    void writeJavaVerifyScalarMethod(ofstream& file) const;
    void writeJavaVerifyVectorMethod(ofstream& file) const;
    void writeJavaVerifyFunctionHeader(ofstream& file) const;
    void writeJavaAllocationDefinition(ofstream& file, const string& indent, const string& name,
                                       const string& cType, bool initialize) const;
    void writeJavaCallToRs(ofstream& file, bool relaxed, bool generateCallToVerify) const;
    void writeJavaAssert(ofstream& file, const ParameterDefinition& verfiedParam) const;

    bool passByAddressToSet(const string& name) const;
    string convertToElementType(const string& name) const;

public:
    Permutation(Function* function, Specification* specification, int i1, int i2, int i3, int i4);
    void writeFiles(ofstream& headerFile, ofstream& rsFile, ofstream& javaFile,
                    int versionOfTestFiles);
    bool hasLongOrDoubleParameter() const;
};

map<string, Function*> Function::sFunctionsMap;

// Table of type equivalences
struct Type {
    const char* specType;  // Name found in the .spec file
    string elementType;    // RS element type
    string cType;          // Type in a C file
    const char* javaType;  // Type in a Java file
};

const Type TYPES[] = {{"f16", "F16", "half", "half"},
                      {"f32", "F32", "float", "float"},
                      {"f64", "F64", "double", "double"},
                      {"i8", "I8", "char", "byte"},
                      {"u8", "U8", "uchar", "byte"},
                      {"i16", "I16", "short", "short"},
                      {"u16", "U16", "ushort", "short"},
                      {"i32", "I32", "int", "int"},
                      {"u32", "U32", "uint", "int"},
                      {"i64", "I64", "long", "long"},
                      {"u64", "U64", "ulong", "long"}};

const int NUM_TYPES = sizeof(TYPES) / sizeof(TYPES[0]);

// Capitalizes and removes underscores.  E.g. converts "native_log" to NativeLog.
string capitalize(const string& source) {
    int length = source.length();
    string result;
    bool capitalize = true;
    for (int s = 0; s < length; s++) {
        if (source[s] == '_') {
            capitalize = true;
        } else if (capitalize) {
            result += toupper(source[s]);
            capitalize = false;
        } else {
            result += source[s];
        }
    }
    return result;
}

string tab(int n) { return string(n * 4, ' '); }

// Return true if the string is already in the set.  Inserts it if not.
bool testAndSet(const string& flag, set<string>* set) {
    if (set->find(flag) == set->end()) {
        set->insert(flag);
        return false;
    }
    return true;
}

// Convert an int into a string.
string toString(int n) {
    char buf[100];
    snprintf(buf, sizeof(buf), "%d", n);
    return string(buf);
}

void trim(string* s, size_t start) {
    if (start > 0) {
        s->erase(0, start);
    }

    while (s->size() && (s->at(0) == ' ')) {
        s->erase(0, 1);
    }

    size_t p = s->find_first_of("\n\r");
    if (p != string::npos) {
        s->erase(p);
    }

    while ((s->size() > 0) && (s->at(s->size() - 1) == ' ')) {
        s->erase(s->size() - 1);
    }
}

string stringReplace(string s, string match, string rep) {
    while (1) {
        size_t p = s.find(match);
        if (p == string::npos) break;

        s.erase(p, match.size());
        s.insert(p, rep);
    }
    return s;
}

// Return the next line from the input file.
bool getNextLine(FILE* in, string* s) {
    s->clear();
    while (1) {
        int c = fgetc(in);
        if (c == EOF) return s->size() != 0;
        if (c == '\n') break;
        s->push_back((char)c);
    }
    return true;
}

void writeIfdef(ofstream& file, string filename, bool isStart) {
    string t = "__";
    t += filename;
    t += "__";

    for (size_t i = 2; i < t.size(); i++) {
        if (t[i] == '.') {
            t[i] = '_';
        }
    }

    if (isStart) {
        file << "#ifndef " << t << "\n";
        file << "#define " << t << "\n";
    } else {
        file << "#endif // " << t << "\n";
    }
}

void writeJavaArrayInitialization(ofstream& file, const ParameterDefinition& p) {
    file << tab(2) << p.javaBaseType << "[] " << p.javaArrayName << " = new " << p.javaBaseType
         << "[INPUTSIZE * " << p.vectorWidth << "];\n";
    file << tab(2) << p.javaAllocName << ".copyTo(" << p.javaArrayName << ");\n";
}

string javaDumpVariable(const string& legend, const string& name, const string& expression,
                        const string& type) {
    string s;
    if (type[0] == 'f') {
        s = "String.format(\"" + legend + " " + name + ":%x %.16f\", Float.floatToRawIntBits(" +
            expression + "), " + expression + ")";
    } else {
        s = "\"" + legend + " " + name + ":\" + " + expression;
    }
    return s;
}

// Read the specification, adding the definitions to the global functions map.
bool readSpecFile() {
    FILE* specFile = fopen(SPEC_FILE_NAME, "rt");
    if (!specFile) {
        printf("Error opening input file: %s", SPEC_FILE_NAME);
        return false;
    }

    while (1) {
        Specification* spec = Specification::scanSpecification(specFile);
        if (spec == NULL) {
            break;
        }
        Function::getFunction(spec->getCleanName())->addSpecification(spec);
    }

    fclose(specFile);
    return true;
}

bool generateFiles(int versionOfTestFiles) {
    printf("Generating test files for version %d\n", versionOfTestFiles);

    // Write the start of the header file.
    ofstream headerFile;
    headerFile.open(HEADER_FILE_NAME, ios::out | ios::trunc);
    if (!headerFile.is_open()) {
        printf("Error opening output file: %s", HEADER_FILE_NAME);
        return false;
    }
    headerFile << LEGAL_NOTICE;
    headerFile << AUTO_GENERATED_WARNING;
    writeIfdef(headerFile, HEADER_FILE_NAME, true);

    // Write the functions to the header and test files.
    bool success = Function::writeAllFunctions(headerFile, versionOfTestFiles);

    // Finish the header file.
    writeIfdef(headerFile, HEADER_FILE_NAME, false);
    headerFile.close();

    return success;
}

// Parse the command line which can have one optional version number.
bool parseCommandLine(int argc, char* argv[], int* versionOfTestFiles) {
    if (argc == 1) {
        return true;
    } else if (argc == 2) {
        char* end;
        *versionOfTestFiles = strtol(argv[1], &end, 10);
        if (*end == '\0') {
            return true;
        }
    }
    printf("Usage: gen_runtime [version_of_test_files]\n");
    return false;
}

/* Parse a parameter definition.  It's of the form "type [*][name]".  The type
 * is required.  The name is optional.  The * indicates it's an output
 * parameter.  We also pass the indexed of this parameter in the definition, so
 * we can create names like in2, in3, etc. */
void ParameterDefinition::parseParameterDefinition(string s, int indexInDefinition) {
    raw = s;

    // Determine if this an output.
    mIsOutParameter = false;
    size_t p = s.find('*');
    if (p != string::npos) {
        mIsOutParameter = true;
        s.erase(p, 1);
    }

    // Separate the type from the name.
    string name;
    p = s.find(' ');
    if (p != string::npos) {
        rsType = s.substr(0, p);
        name = capitalize(s.substr(p + 1));
    } else {
        rsType = s;
    }
    int last = rsType.size() - 1;
    char lastChar = rsType[last];
    if (lastChar >= '0' && lastChar <= '9') {
        rsBaseType = rsType.substr(0, last);
        mVectorSize = lastChar;
    } else {
        rsBaseType = rsType;
        mVectorSize = "1";
    }
    if (mVectorSize == "3") {
        vectorWidth = "4";
    } else {
        vectorWidth = mVectorSize;
    }

    /* Create variable names to be used in the java and .rs files.  Because x and
     * y are reserved in .rs files, we prefix variable names with "in" or "out".
     */
    if (mIsOutParameter) {
        variableName = "out";
    } else {
        variableName = "in";
    }
    if (!name.empty()) {
        variableName += name;
    } else {
        if (indexInDefinition > 0) {
            variableName += toString(indexInDefinition);
        }
    }
    rsAllocName = "gAlloc" + capitalize(variableName);
    javaAllocName = variableName;
    javaArrayName = "array" + capitalize(javaAllocName);
    javaActualName = "actual" + capitalize(variableName);

    for (int i = 0; i < NUM_TYPES; i++) {
        if (rsBaseType == TYPES[i].cType) {
            javaBaseType = TYPES[i].javaType;
            break;
        }
    }
}

Function::Function(const string& name) {
    mName = name;
    mCapitalizedName = capitalize(mName);
    mTestName = "Test" + mCapitalizedName;
    mRelaxedTestName = mTestName + "Relaxed";
}

// Return the named function from the map.  Creates it if it's not there.
Function* Function::getFunction(const string& name) {
    FunctionsIterator iter = sFunctionsMap.find(name);
    if (iter != sFunctionsMap.end()) {
        return iter->second;
    }
    Function* f = new Function(name);
    sFunctionsMap[name] = f;
    return f;
}

// Returns the largest known version number.
int Function::largestVersionNumber() {
    int version = 0;
    for (FunctionsIterator iter = sFunctionsMap.begin(); iter != sFunctionsMap.end(); iter++) {
        Function* func = iter->second;
        for (SpecificationIterator iter = func->mSpecifications.begin();
             iter != func->mSpecifications.end(); iter++) {
            Specification& spec = **iter;
            int specMin = spec.getMinVersion();
            int specMax = spec.getMaxVersion();
            if (specMin && specMin > version) {
                version = specMin;
            }
            if (specMax && specMax > version) {
                version = specMax;
            }
        }
    }
    return version;
}

bool Function::writeAllFunctions(ofstream& headerFile, int versionOfTestFiles) {
    bool success = true;
    for (FunctionsIterator iter = sFunctionsMap.begin(); iter != sFunctionsMap.end(); iter++) {
        Function* func = iter->second;
        if (!func->writeFiles(headerFile, versionOfTestFiles)) {
            success = false;
        }
    }
    return success;
}

bool Function::writeFiles(ofstream& headerFile, int versionOfTestFiles) {
    if (!startRsFile() || !startJavaFile() || !writeRelaxedRsFile()) {
        return false;
    }

    for (SpecificationIterator i = mSpecifications.begin(); i < mSpecifications.end(); i++) {
        (*i)->writeFiles(headerFile, mRsFile, mJavaFile, this, versionOfTestFiles);
    }

    finishJavaFile();
    // There's no work to wrap-up in the .rs file.

    mRsFile.close();
    mJavaFile.close();
    return true;
}

bool Function::startRsFile() {
    string fileName = mTestName + ".rs";
    mRsFile.open(fileName.c_str(), ios::out | ios::trunc);
    if (!mRsFile.is_open()) {
        printf("Error opening file: %s", fileName.c_str());
        return false;
    }
    mRsFile << LEGAL_NOTICE;
    mRsFile << "#pragma version(1)\n";
    mRsFile << "#pragma rs java_package_name(android.renderscript.cts)\n\n";
    mRsFile << AUTO_GENERATED_WARNING;
    return true;
}

// Write an allocation definition if not already emitted in the .rs file.
void Function::writeRsAllocationDefinition(const ParameterDefinition& param) {
    if (!testAndSet(param.rsAllocName, &mRsAllocationsGenerated)) {
        mRsFile << "rs_allocation " << param.rsAllocName << ";\n";
    }
}

// Write the entire *Relaxed.rs test file, as it only depends on the name.
bool Function::writeRelaxedRsFile() {
    string name = mRelaxedTestName + ".rs";
    FILE* file = fopen(name.c_str(), "wt");
    if (!file) {
        printf("Error opening file: %s", name.c_str());
        return false;
    }
    fputs(LEGAL_NOTICE, file);
    string s;
    s += "#include \"" + mTestName + ".rs\"\n";
    s += "#pragma rs_fp_relaxed\n";
    s += AUTO_GENERATED_WARNING;
    fputs(s.c_str(), file);
    fclose(file);
    return true;
}

bool Function::startJavaFile() {
    string fileName = mTestName + ".java";
    mJavaFile.open(fileName.c_str(), ios::out | ios::trunc);
    if (!mJavaFile.is_open()) {
        printf("Error opening file: %s", fileName.c_str());
        return false;
    }
    mJavaFile << LEGAL_NOTICE;
    mJavaFile << AUTO_GENERATED_WARNING;
    mJavaFile << "package android.renderscript.cts;\n\n";

    mJavaFile << "import android.renderscript.Allocation;\n";
    mJavaFile << "import android.renderscript.RSRuntimeException;\n";
    mJavaFile << "import android.renderscript.Element;\n\n";

    mJavaFile << "public class " << mTestName << " extends RSBaseCompute {\n\n";

    mJavaFile << tab(1) << "private ScriptC_" << mTestName << " script;\n";
    mJavaFile << tab(1) << "private ScriptC_" << mRelaxedTestName << " scriptRelaxed;\n\n";

    mJavaFile << tab(1) << "@Override\n";
    mJavaFile << tab(1) << "protected void setUp() throws Exception {\n";
    mJavaFile << tab(2) << "super.setUp();\n";
    mJavaFile << tab(2) << "script = new ScriptC_" << mTestName << "(mRS);\n";
    mJavaFile << tab(2) << "scriptRelaxed = new ScriptC_" << mRelaxedTestName << "(mRS);\n";
    mJavaFile << tab(1) << "}\n\n";
    return true;
}

void Function::writeJavaArgumentClassDefinition(const string& className, const string& definition) {
    if (!testAndSet(className, &mJavaGeneratedArgumentClasses)) {
        mJavaFile << definition;
    }
}

void Function::addJavaCheckCall(const string& call) {
    mJavaCallAllCheckMethods += tab(2) + call + "\n";
}

void Function::finishJavaFile() {
    mJavaFile << tab(1) << "public void test" << mCapitalizedName << "() {\n";
    mJavaFile << mJavaCallAllCheckMethods;
    mJavaFile << tab(1) << "}\n";
    mJavaFile << "}\n";
}

void Specification::expandStringVector(const vector<string>& in, int i1, int i2, int i3, int i4,
                                       vector<string>* out) const {
    out->clear();
    for (vector<string>::const_iterator iter = in.begin(); iter != in.end(); iter++) {
        out->push_back(expandString(*iter, i1, i2, i3, i4));
    }
}

Specification* Specification::scanSpecification(FILE* in) {
    Specification* spec = new Specification();
    spec->mTest = "scalar";  // default
    bool modeComment = false;
    bool modeInline = false;
    bool success = true;

    while (1) {
        string s;
        bool ret = getNextLine(in, &s);
        if (!ret) break;

        if (modeComment) {
            if (!s.size() || (s[0] == ' ')) {
                trim(&s, 0);
                spec->mComment.push_back(s);
                continue;
            } else {
                modeComment = false;
            }
        }

        if (modeInline) {
            if (!s.size() || (s[0] == ' ')) {
                trim(&s, 0);
                spec->mInline.push_back(s);
                continue;
            } else {
                modeInline = false;
            }
        }

        if (s[0] == '#') {
            continue;
        }

        if (s.compare(0, 5, "name:") == 0) {
            trim(&s, 5);
            spec->mName = s;
            // Some functions like convert have # part of the name.  Truncate at that point.
            size_t p = s.find('#');
            if (p != string::npos) {
                if (p > 0 && s[p - 1] == '_') {
                    p--;
                }
                s.erase(p);
            }
            spec->mCleanName = s;
            continue;
        }

        if (s.compare(0, 4, "arg:") == 0) {
            trim(&s, 4);
            spec->mParam.push_back(s);
            continue;
        }

        if (s.compare(0, 4, "ret:") == 0) {
            trim(&s, 4);
            spec->mReturn = s;
            continue;
        }

        if (s.compare(0, 5, "test:") == 0) {
            trim(&s, 5);
            if (s == "scalar" || s == "vector" || s == "noverify" || s == "none") {
                spec->mTest = s;
            } else {
                printf("Unrecognized test option: %s\n", s.c_str());
                success = false;
            }
            continue;
        }

        if (s.compare(0, 4, "end:") == 0) {
            if (success) {
                return spec;
            } else {
                delete spec;
                return NULL;
            }
        }

        if (s.compare(0, 8, "comment:") == 0) {
            modeComment = true;
            continue;
        }

        if (s.compare(0, 7, "inline:") == 0) {
            modeInline = true;
            continue;
        }

        if (s.compare(0, 8, "version:") == 0) {
            trim(&s, 8);
            sscanf(s.c_str(), "%i %i", &spec->mMinVersion, &spec->mMaxVersion);
            continue;
        }

        if (s.compare(0, 8, "start:") == 0) {
            continue;
        }

        if (s.compare(0, 2, "w:") == 0) {
            vector<string> t;
            if (s.find("1") != string::npos) {
                t.push_back("");
            }
            if (s.find("2") != string::npos) {
                t.push_back("2");
            }
            if (s.find("3") != string::npos) {
                t.push_back("3");
            }
            if (s.find("4") != string::npos) {
                t.push_back("4");
            }
            spec->mReplaceables.push_back(t);
            continue;
        }

        if (s.compare(0, 2, "t:") == 0) {
            vector<string> t;
            for (int i = 0; i < NUM_TYPES; i++) {
                if (s.find(TYPES[i].specType) != string::npos) {
                    t.push_back(TYPES[i].cType);
                }
            }
            spec->mReplaceables.push_back(t);
            continue;
        }

        if (s.size() == 0) {
            // eat empty line
            continue;
        }

        printf("Error, line:\n");
        printf("  %s\n", s.c_str());
    }

    delete spec;
    return NULL;
}

void Specification::writeFiles(ofstream& headerFile, ofstream& rsFile, ofstream& javaFile,
                               Function* function, int versionOfTestFiles) {
    int start[4];
    int end[4];
    for (int i = 0; i < 4; i++) {
        if (i < (int)mReplaceables.size()) {
            start[i] = 0;
            end[i] = mReplaceables[i].size();
        } else {
            start[i] = -1;
            end[i] = 0;
        }
    }
    for (int i4 = start[3]; i4 < end[3]; i4++) {
        for (int i3 = start[2]; i3 < end[2]; i3++) {
            for (int i2 = start[1]; i2 < end[1]; i2++) {
                for (int i1 = start[0]; i1 < end[0]; i1++) {
                    Permutation p(function, this, i1, i2, i3, i4);
                    p.writeFiles(headerFile, rsFile, javaFile, versionOfTestFiles);
                }
            }
        }
    }
}

bool Specification::relevantForVersion(int versionOfTestFiles) const {
    if (mMinVersion != 0 && mMinVersion > versionOfTestFiles) {
        return false;
    }
    if (mMaxVersion != 0 && mMaxVersion < versionOfTestFiles) {
        return false;
    }
    return true;
}

string Specification::expandString(string s, int i1, int i2, int i3, int i4) const {
    if (mReplaceables.size() > 0) {
        s = stringReplace(s, "#1", mReplaceables[0][i1]);
    }
    if (mReplaceables.size() > 1) {
        s = stringReplace(s, "#2", mReplaceables[1][i2]);
    }
    if (mReplaceables.size() > 2) {
        s = stringReplace(s, "#3", mReplaceables[2][i3]);
    }
    if (mReplaceables.size() > 3) {
        s = stringReplace(s, "#4", mReplaceables[3][i4]);
    }
    return s;
}

Permutation::Permutation(Function* func, Specification* spec, int i1, int i2, int i3, int i4)
    : function(func), specification(spec) {
    // We expand the strings now to make capitalization easier.  The previous code preserved the #n
    // markers just before emitting, which made capitalization difficult.
    mName = specification->getName(i1, i2, i3, i4);
    mCleanName = specification->getCleanName();
    mCapitalizedName = capitalize(mName);
    mTest = specification->getTest();
    specification->getInlines(i1, i2, i3, i4, &mInline);
    specification->getComments(i1, i2, i3, i4, &mComment);

    vector<string> paramDefinitions;
    specification->getParams(i1, i2, i3, i4, &paramDefinitions);
    for (size_t i = 0; i < paramDefinitions.size(); i++) {
        ParameterDefinition* def = new ParameterDefinition();
        def->parseParameterDefinition(paramDefinitions[i], i);
        if (i == 0 && def->mIsOutParameter) {
            printf("The first parameter of a function should not be an out parameter.\n");
        }
        mParams.push_back(def);
    }
    string s = specification->getReturn(i1, i2, i3, i4);
    // Adding "*" tells the parse method it's an output.
    mReturn.parseParameterDefinition(s + "*", 0);

    mRsKernelName = "test" + capitalize(mName);
    for (size_t i = 0; i < mParams.size(); i++) {
        mRsKernelName += capitalize(mParams[i]->rsType);
    }

    string signature;      // with the sizes, e.g. Float4Float4
    string signatureN;     // same but with N instead of the number, e.g. FloatNFloatN
    string baseSignature;  // without the sizes, e.g. FloatFloat
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        signature += capitalize(p.rsType);
        baseSignature += capitalize(p.rsBaseType);
        signatureN += capitalize(p.rsBaseType);
        if (p.mVectorSize != "1") {
            signatureN += "N";
        }
    }
    mJavaArgumentsClassName = "Arguments" + baseSignature + capitalize(mReturn.rsBaseType);
    mJavaArgumentsNClassName = "Arguments" + signatureN + capitalize(mReturn.rsBaseType);
    if (mReturn.mVectorSize != "1") {
        mJavaArgumentsNClassName += "N";
    }
    mJavaCheckMethodName = "check" + mCapitalizedName + signature;
    mJavaVerifyMethodName = "verifyResults" + mCapitalizedName + signature;
    mJavaVerifierComputeMethodName = "compute" + capitalize(mCleanName);
}

bool Permutation::hasLongOrDoubleParameter() const {
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (p.javaBaseType == "long" || p.javaBaseType == "double") {
            return true;
        }
    }
    return mReturn.javaBaseType == "long" || mReturn.javaBaseType == "double";
}

void Permutation::writeFiles(ofstream& headerFile, ofstream& rsFile, ofstream& javaFile,
                             int versionOfTestFiles) {
    writeHeaderSection(headerFile);
    if (hasLongOrDoubleParameter()) {
        printf("Warning: skipping a test for %s as we don't support long or double argurments (due "
               "to Allocation not supporting them).\n",
               mName.c_str());
        return;
    }

    if (specification->relevantForVersion(versionOfTestFiles) && mTest != "none") {
        writeRsSection(rsFile);
        writeJavaSection(javaFile);
    }
}

void Permutation::writeHeaderSection(ofstream& file) const {
    int minVersion = specification->getMinVersion();
    int maxVersion = specification->getMaxVersion();
    bool hasVersion = minVersion || maxVersion;

    if (hasVersion) {
        if (maxVersion) {
            file << "#if (defined(RS_VERSION) && (RS_VERSION >= " << minVersion
                 << ") && (RS_VERSION <= " << maxVersion << "))\n";
        } else {
            file << "#if (defined(RS_VERSION) && (RS_VERSION >= " << minVersion << "))\n";
        }
    }

    file << "/*\n";
    for (size_t ct = 0; ct < mComment.size(); ct++) {
        if (!mComment[ct].empty()) {
            file << " * " << mComment[ct] << "\n";
        } else {
            file << " *\n";
        }
    }
    file << " *\n";
    if (minVersion || maxVersion) {
        if (maxVersion) {
            file << " * Suppored by API versions " << minVersion << " - " << maxVersion << "\n";
        } else {
            file << " * Supported by API versions " << minVersion << " and newer.\n";
        }
    }
    file << " */\n";
    if (mInline.size() > 0) {
        file << "static ";
    } else {
        file << "extern ";
    }
    file << mReturn.rsType;
    file << " __attribute__((const, overloadable))";
    file << mName;
    file << "(";
    if (mParams.size() > 0) {
        file << mParams[0]->raw;
        for (size_t ct = 1; ct < mParams.size(); ct++) {
            file << ", ";
            file << mParams[ct]->raw;
        }
    }
    if (mInline.size() > 0) {
        file << ") {\n";
        for (size_t ct = 0; ct < mInline.size(); ct++) {
            file << " " << mInline[ct].c_str() << "\n";
        }
        file << "}\n";
    } else {
        file << ");\n";
    }
    if (hasVersion) {
        file << "#endif\n";
    }
    file << "\n";
}

/* Write the section of the .rs file for this permutation.
 *
 * We communicate the extra input and output parameters via global allocations.
 * For example, if we have a function that takes three arguments, two for input
 * and one for output:
 *
 * start:
 * name: gamn
 * ret: float3
 * arg: float3 a
 * arg: int b
 * arg: float3 *c
 * end:
 *
 * We'll produce:
 *
 * rs_allocation gAllocInB;
 * rs_allocation gAllocOutC;
 *
 * float3 __attribute__((kernel)) test_gamn_float3_int_float3(float3 inA, unsigned int x) {
 *    int inB;
 *    float3 outC;
 *    float2 out;
 *    inB = rsGetElementAt_int(gAllocInB, x);
 *    out = gamn(a, in_b, &outC);
 *    rsSetElementAt_float4(gAllocOutC, &outC, x);
 *    return out;
 * }
 *
 * We avoid re-using x and y from the definition because these have reserved
 * meanings in a .rs file.
 */
void Permutation::writeRsSection(ofstream& rs) const {
    // Write the allocation declarations we'll need.
    for (size_t i = 1; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        function->writeRsAllocationDefinition(p);
    }
    rs << "\n";

    bool hasOutParameters = false;
    for (size_t i = 0; i < mParams.size(); i++) {
        if (mParams[i]->mIsOutParameter) {
            hasOutParameters = true;
            break;
        }
    }

    // Write the function header.
    rs << mReturn.rsType << " __attribute__((kernel)) " << mRsKernelName;
    rs << "(" << mParams[0]->rsType << " " << mParams[0]->variableName;
    if (hasOutParameters || mParams.size() > 1) {
        rs << ", unsigned int x";
    }
    rs << ") {\n";

    // Write the local variable declarations.
    for (size_t i = 1; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        rs << tab(1) << p.rsType << " " << p.variableName << ";\n";
    }
    if (hasOutParameters) {
        rs << tab(1) << mReturn.rsType << " " << mReturn.variableName << ";\n";
    }

    // Write reading the extra input variables.
    for (size_t i = 1; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (!p.mIsOutParameter) {
            rs << tab(1) << p.variableName << " = rsGetElementAt_" << p.rsType;
            rs << "(" << p.rsAllocName << ", x);\n";
        }
    }

    // Write the function call.
    if (hasOutParameters) {
        rs << tab(1) << mReturn.variableName << " = ";
    } else {
        rs << tab(1) << "return ";
    }
    rs << mName << "(" << mParams[0]->variableName;
    for (size_t i = 1; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        rs << ", ";
        if (p.mIsOutParameter) {
            rs << "&";
        }
        rs << p.variableName;
    }
    rs << ");\n";

    if (hasOutParameters) {
        // Write setting the extra out parameters into the allocations.
        for (size_t i = 1; i < mParams.size(); i++) {
            const ParameterDefinition& p = *mParams[i];
            if (p.mIsOutParameter) {
                rs << tab(1) << "rsSetElementAt_" << p.rsType << "(" << p.rsAllocName << ", ";
                if (passByAddressToSet(p.variableName)) {
                    rs << "&";
                }
                rs << p.variableName << ", x);\n";
            }
        }
        rs << tab(1) << "return " << mReturn.variableName << ";\n";
    }
    rs << "}\n";
}

bool Permutation::passByAddressToSet(const string& name) const {
    string s = name;
    int last = s.size() - 1;
    char lastChar = s[last];
    return lastChar >= '0' && lastChar <= '9';
}

void Permutation::writeJavaSection(ofstream& file) const {
    // By default, we test the results using item by item comparison.
    if (mTest == "scalar") {
        writeJavaArgumentClass(file, true);
        writeJavaCheckMethod(file, true);
        writeJavaVerifyScalarMethod(file);
    } else if (mTest == "vector") {
        writeJavaArgumentClass(file, false);
        writeJavaCheckMethod(file, true);
        writeJavaVerifyVectorMethod(file);
    } else if (mTest == "noverify") {
        writeJavaCheckMethod(file, false);
    }

    // Register the check method to be called.  This code will be written at the end.
    function->addJavaCheckCall(mJavaCheckMethodName + "();");
}

void Permutation::writeJavaArgumentClass(ofstream& file, bool scalar) const {
    string name;
    if (scalar) {
        name = mJavaArgumentsClassName;
    } else {
        name = mJavaArgumentsNClassName;
    }
    string s;
    s += tab(1) + "public class " + name + " {\n";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        s += tab(2) + "public " + p.javaBaseType;
        if (!scalar && p.mVectorSize != "1") {
            s += "[]";
        }
        s += " " + p.variableName + ";\n";
    }
    s += tab(2) + "public " + mReturn.javaBaseType;
    if (!scalar && mReturn.mVectorSize != "1") {
        s += "[]";
    }
    s += " " + mReturn.variableName + ";\n\n";

    s += tab(2) + "public int ulf;\n";
    s += tab(2) + "public int ulfRelaxed;\n";
    s += tab(1) + "}\n\n";

    function->writeJavaArgumentClassDefinition(name, s);
}

void Permutation::writeJavaCheckMethod(ofstream& file, bool generateCallToVerify) const {
    file << tab(1) << "private void " << mJavaCheckMethodName << "() {\n";
    // Generate the input allocations and initialization.
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (!p.mIsOutParameter) {
            writeJavaAllocationDefinition(file, tab(2), p.javaAllocName, p.rsType, true);
        }
    }
    writeJavaCallToRs(file, false, generateCallToVerify);
    writeJavaCallToRs(file, true, generateCallToVerify);
    file << tab(1) << "}\n\n";
}

void Permutation::writeJavaAllocationDefinition(ofstream& file, const string& indent,
                                                const string& name, const string& cType,
                                                bool initialize) const {
    string elementType = convertToElementType(cType);
    file << indent << "Allocation " << name << " = Allocation.createSized(mRS, Element."
         << elementType << "(mRS), INPUTSIZE);\n";
    if (initialize) {
        // TODO set the seed
        // TODO set the range better
        // TODO merge initfunctionname into TypeEquivalence
        // TODO need to initialize for other types like char, short, double
        if (elementType[0] == 'I') {
            file << indent << "RandomizeWithInts(" << name
                 << ", 0x23, -500, 400);  // seed is x23\n";
        } else if (elementType[0] == 'U') {
            file << indent << "RandomizeWithInts(" << name << ", 0x23, 0, 500);  // seed is x23\n";
        } else if (elementType[0] == 'F') {
            file << indent << "RandomizeWithFloats(" << name
                 << ", 0x23, 0.0f, 1.0f);  // seed is x23\n";
        } else {
            printf("TODO Don't know how to initialize %s\n", elementType.c_str());
        }
    }
}

// Converts float2 to F32_2, etc.
string Permutation::convertToElementType(const string& name) const {
    //    printf("convertto %s\n", name.c_str());
    string s = name;
    int last = s.size() - 1;
    char lastChar = s[last];
    bool hasSize = false;
    if (lastChar >= '0' && lastChar <= '9') {
        s.erase(last);
        hasSize = true;
    }
    string answer;
    for (int i = 0; i < NUM_TYPES; i++) {
        if (s == TYPES[i].cType) {
            answer = TYPES[i].elementType;
            break;
        }
    }
    if (answer.empty()) {
        printf("how to do %s?\n", s.c_str());
    }

    if (hasSize && lastChar != '1') {
        answer += "_";
        answer += lastChar;
    }
    return answer;
}

void Permutation::writeJavaVerifyScalarMethod(ofstream& file) const {
    writeJavaVerifyFunctionHeader(file);
    string vectorSize = "1";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        writeJavaArrayInitialization(file, p);
        if (p.mVectorSize != "1" && p.mVectorSize != vectorSize) {
            if (vectorSize == "1") {
                vectorSize = p.mVectorSize;
            } else {
                printf("Yikes, had vector %s and %s\n", vectorSize.c_str(), p.mVectorSize.c_str());
            }
        }
    }
    writeJavaArrayInitialization(file, mReturn);

    file << tab(2) << "for (int i = 0; i < INPUTSIZE; i++) {\n";
    file << tab(3) << "for (int j = 0; j < " << vectorSize << " ; j++) {\n";
    file << tab(4) << mJavaArgumentsClassName << " args = new " << mJavaArgumentsClassName
         << "();\n";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        file << tab(4) << "args." << p.variableName << " = " << p.javaArrayName << "[i";
        if (p.vectorWidth != "1") {
            file << " * " << p.vectorWidth << " + j";
        }
        file << "];\n";
    }
    file << tab(4) << "CoreMathVerifier." << mJavaVerifierComputeMethodName << "(args);\n";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (p.mIsOutParameter) {
            file << tab(4) << p.javaBaseType << " " << p.javaActualName << " = " << p.javaArrayName
                 << "[i * " << p.vectorWidth << " + j];\n";
        }
    }
    file << tab(4) << mReturn.javaBaseType << " " << mReturn.javaActualName << " = "
         << mReturn.javaArrayName << "[i * " << mReturn.vectorWidth << " + j];\n";
    file << tab(4) << "int ulf = relaxed ? args.ulfRelaxed : args.ulf;\n";
    file << tab(4) << "float ulpf;\n";
    writeJavaAssert(file, mReturn);
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (p.mIsOutParameter) {
            writeJavaAssert(file, p);
        }
    }
    file << tab(3) << "}\n";
    file << tab(2) << "}\n";
    file << tab(1) << "}\n\n";
}

void Permutation::writeJavaVerifyFunctionHeader(ofstream& file) const {
    file << tab(1) << "private void " << mJavaVerifyMethodName << "(";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        file << "Allocation " << p.javaAllocName << ", ";
    }
    file << "Allocation " << mReturn.variableName << ", boolean relaxed) {\n";
}

void Permutation::writeJavaAssert(ofstream& file, const ParameterDefinition& verifiedParam) const {
    file << tab(4) << "ulpf = Math.ulp(args." << verifiedParam.variableName << ") * ulf;\n";
    file << tab(4) << "assertEquals(\n";
    file << tab(5) << "\"Incorrect output for "
         << mJavaCheckMethodName + "\" + (relaxed ? \"_relaxed\" : \"\") + \""
         << " @[\" + i + \", \" + j + \"] with ulf:\" + ulf + \".\\n\" +\n";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (!p.mIsOutParameter) {
            file << tab(5) << javaDumpVariable("Input", p.variableName, "args." + p.variableName,
                                               p.rsBaseType) << " + \"\\n\" +\n";
        } else {
            file << tab(5) << javaDumpVariable("Expected output", p.variableName,
                                               "args." + p.variableName, p.rsBaseType)
                 << " + \"\\n\" +\n";
            file << tab(5) << javaDumpVariable("Actual   output", p.variableName, p.javaActualName,
                                               p.rsBaseType) << " + \"\\n\" +\n";
        }
    }
    file << tab(5) << javaDumpVariable("Expected output", mReturn.variableName,
                                       "args." + mReturn.variableName, mReturn.rsBaseType)
         << " + \"\\n\" +\n";
    file << tab(5) << javaDumpVariable("Actual   output", mReturn.variableName,
                                       mReturn.javaActualName, mReturn.rsBaseType)
         << " + \"\\n\",\n";
    file << tab(5) << "args." << verifiedParam.variableName << ", " << verifiedParam.javaActualName
         << ", ulpf);\n";
}

void writeJavaCompareAndAppendToMessage(ofstream& file, const string& actualName,
                                        const string& actual, const string& fieldName,
                                        const string& rsBaseType, int indent) {
    file << tab(indent) << "if (Math.abs(args." << fieldName << " - " << actual
         << ") > Math.ulp(args." << fieldName << ") * ulf) {\n";
    file << tab(indent + 1) << "valid = false;\n";
    file << tab(indent + 1) << "s = \"FAIL\";\n";
    file << tab(indent) << "} else {\n";
    file << tab(indent + 1) << "s = \"OK\";\n";
    file << tab(indent) << "}\n";
    file << tab(indent) << "message.append("
         << javaDumpVariable("Expected output", fieldName, "args." + fieldName, rsBaseType)
         << " + \"\\n\");\n";
    file << tab(indent) << "message.append("
         << javaDumpVariable("Actual   output", actualName, actual, rsBaseType)
         << " + \" \" + s + \"\\n\");\n";
}

void writeJavaSetAndAppendToMessage(ofstream& file, const string& value, const string& fieldName,
                                    const string& rsBaseType, int indent) {
    file << tab(indent) << "args." << fieldName << " = " << value << ";\n";
    file << tab(indent) << "message.append("
         << javaDumpVariable("Input", fieldName, "args." + fieldName, rsBaseType)
         << " + \"\\n\");\n";
}

void writeJavaVectorComparison(ofstream& file, const ParameterDefinition& p) {
    if (p.mVectorSize == "1") {
        writeJavaCompareAndAppendToMessage(file, p.variableName, p.javaArrayName + "[i]",
                                           p.variableName, p.rsBaseType, 3);
    } else {
        file << tab(3) << "for (int j = 0; j < " << p.mVectorSize << " ; j++) {\n";
        writeJavaCompareAndAppendToMessage(file, p.variableName,
                                           p.javaArrayName + "[i * " + p.vectorWidth + " + j]",
                                           p.variableName + "[j]", p.rsBaseType, 4);
        file << tab(3) << "}\n";
    }
}

void Permutation::writeJavaVerifyVectorMethod(ofstream& file) const {
    writeJavaVerifyFunctionHeader(file);
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        writeJavaArrayInitialization(file, p);
    }
    writeJavaArrayInitialization(file, mReturn);
    file << tab(2) + "for (int i = 0; i < INPUTSIZE; i++) {\n";
    file << tab(3) << "StringBuilder message = new StringBuilder();\n";
    file << tab(3) << mJavaArgumentsNClassName << " args = new " << mJavaArgumentsNClassName
         << "();\n";
    file << tab(3) << "// Create the appropriate sized arrays in args\n";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (p.mVectorSize != "1") {
            file << tab(3) << "args." << p.variableName << " = new " << p.javaBaseType << "["
                 << p.mVectorSize << "];\n";
        }
    }
    if (mReturn.mVectorSize != "1") {
        file << tab(3) << "args." << mReturn.variableName << " = new " << mReturn.javaBaseType
             << "[" << mReturn.mVectorSize << "];\n";
    }
    file << tab(3) << "// Fill args with the input values\n";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (!p.mIsOutParameter) {
            if (p.mVectorSize == "1") {
                writeJavaSetAndAppendToMessage(file, p.javaArrayName + "[i]", p.variableName,
                                               p.rsBaseType, 3);
            } else {
                file << tab(3) << "for (int j = 0; j < " << p.mVectorSize << " ; j++) {\n";
                writeJavaSetAndAppendToMessage(file,
                                               p.javaArrayName + "[i * " + p.vectorWidth + " + j]",
                                               p.variableName + "[j]", p.rsBaseType, 4);
                file << tab(3) << "}\n";
            }
        }
    }
    file << tab(3) << "CoreMathVerifier." << mJavaVerifierComputeMethodName << "(args);\n\n";
    file << tab(3) << "// Compare the expected outputs to the actual values returned by RS.\n";
    file << tab(3) << "int ulf = relaxed ? args.ulfRelaxed : args.ulf;\n";
    file << tab(3) << "float ulpf;\n";
    file << tab(3) << "String s;\n";
    file << tab(3) << "boolean valid = true;\n";
    for (size_t i = 0; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (p.mIsOutParameter) {
            writeJavaVectorComparison(file, p);
        }
    }
    writeJavaVectorComparison(file, mReturn);

    file << tab(3) << "assertTrue(\"Incorrect output for " << mJavaCheckMethodName
         << "\" + (relaxed ? \"_relaxed\" : \"\") + \" @[\" + i + \"] with ulf:\" + ulf + \".\\n\" "
            "+ message.toString(), valid);\n";
    file << tab(2) << "}\n";
    file << tab(1) << "}\n";
}

void Permutation::writeJavaCallToRs(ofstream& file, bool relaxed, bool generateCallToVerify) const {
    string script = "script";
    if (relaxed) {
        script += "Relaxed";
    }

    file << tab(2) << "try {\n";
    for (size_t i = 1; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        if (p.mIsOutParameter) {
            writeJavaAllocationDefinition(file, tab(3), p.javaAllocName, p.rsType, false);
        }
    }
    writeJavaAllocationDefinition(file, tab(3), mReturn.variableName, mReturn.rsType, false);

    for (size_t i = 1; i < mParams.size(); i++) {
        const ParameterDefinition& p = *mParams[i];
        file << tab(3) << script << ".set_" << p.rsAllocName << "(" << p.javaAllocName << ");\n";
    }

    file << tab(3) << script << ".forEach_" << mRsKernelName << "(" << mParams[0]->javaAllocName
         << ", " << mReturn.variableName << ");\n";

    if (generateCallToVerify) {
        file << tab(3) << mJavaVerifyMethodName << "(";
        for (size_t i = 0; i < mParams.size(); i++) {
            const ParameterDefinition& p = *mParams[i];
            file << p.variableName << ", ";
        }
        file << mReturn.variableName << ", ";

        if (relaxed) {
            file << "true";
        } else {
            file << "false";
        }
        file << ");\n";
    }
    file << tab(2) << "} catch (Exception e) {\n";
    file << tab(3) << "throw new RSRuntimeException(\"RenderScript. Can't invoke forEach_"
         << mRsKernelName << ": \" + e.toString());\n";
    file << tab(2) << "}\n";
}

}  // namespace

int main(int argc, char* argv[]) {
    if (!readSpecFile()) {
        return -1;
    }
    int versionOfTestFiles = 0;
    if (!parseCommandLine(argc, argv, &versionOfTestFiles)) {
        return -1;
    }
    if (versionOfTestFiles == 0) {
        versionOfTestFiles = Function::largestVersionNumber();
    }
    if (!generateFiles(versionOfTestFiles)) {
        return -1;
    }
    printf("%d functions processed.\n", Function::numberOfFunctions());
    return 0;
}
